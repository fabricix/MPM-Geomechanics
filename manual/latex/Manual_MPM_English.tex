% SPDX-License-Identifier: MIT
% Copyright (c) 2021-2025 MPM-Geomechanics Development Team

\documentclass[11pt,a4paper]{article}

% Minimal
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{geometry} 
\geometry{margin=2.5cm}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}

% Math and units
\usepackage{amsmath,amssymb,mathtools}
\usepackage{siunitx}
\sisetup{detect-all, per-mode=symbol}

% Figures and tables
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{float}

% Code listings
\usepackage{listings}

\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=true,
  numbers=left,
  numberstyle=\tiny,
  tabsize=2,
  showstringspaces=false
}

% algorithm
\usepackage{algorithm}
\usepackage{algpseudocode}

% Metadata

\title{
  \textbf{MPM-Geomechanics Manual} \\
  \large An open-source Material Point Method code for geomechanics.
}

\author{Prof. Dr. Fabricio Fernández \\ MPM-Geomechanics Development Team}

\date{\today}

\begin{document}

\maketitle

\section{Introduction to the Material Point Method (MPM)}

The Material Point Method is an hybrid Lagrangian-Eulerian numerical method, that allows for simulating continuum mechanics processes involving large deformations and displacements without issues related to computational mesh distortion. In MPM, the material domain to be simulated is discretized into a set of material points that can move freely within a computational mesh, where the equations of motion are solved. The material points store all variables of interest during the simulation, such as stress, pore pressure, temperature, etc., giving the method its Lagrangian characteristic. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.65\linewidth]{figures/mpm_discretization}
	\caption {General MPM approach. Solid and space discretization with Lagrangian material points and structured Eulerian mesh.}
	\label{fig:mpm-discretization}
\end{figure}

In an MPM computational cycle, all variables stored in the material points are computed at the computational mesh nodes using interpolation functions, and then the equation of motion is solved at the nodes. The nodal solution obtained is interpolated back to the particles, whose positions are updated, and all nodal variables are discarded. This method, enables the numerical solution of the motion equation in continuum mechanics by using the nodes of an Eulerian mesh for integration and Lagrangian material points to transfer and store the properties of the medium.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{figures/mpm_cycle.png}
	\caption{MPM computational cycle}
	\label{fig:mpmcycle}
\end{figure}

\section{MPM Formulation}

The material point method formulation is based on the continuum mechanics motion equation in 3D:

\begin{equation}
\frac{\partial \sigma_{ij}}{\partial x_j} + \rho b_i = \rho a_i
\label{eq-motion}
\end{equation}

The internal forces are related with the $\sigma_{ij} $, the Cauchy stress tensor, $\rho$ is the mass density, $b_i$ is a body force and $a_i$ is the acceleration.

The equation \ref{eq-motion} is presented here in tensor notation, but, vector and matrix can be equally used. The discrete form of the motion equation can be obtained using the weak form of this partial differential equation. The weak form is obtained by multiplying the motion equation by arbitrary weighting functions and integrating this product over the domain. In this procedure, the integration by parts reduces the order the stress tensor and introduces the natural boundary conditions:

\begin{equation}
-\int_{\Omega} \sigma_{i j} \delta u_{i, j} dV + \int_{\Gamma} t_i \delta u_i dA + \int_{\Omega} \rho b_i \delta u_i dV = \int_{\Omega} \rho a_i \delta u_i dV
\label{eq-weak-form-motion}
\end{equation}

Here $\delta u_i$ are arbitrary displacements functions, whose value in the boundary are $\delta u_i |_{\Gamma} = 0$ and $t_i$ is an external traction acting on the boundary $\Gamma$.

In the MPM context any field or space property $f(x_i)$ can approximated using the value stored in the particle $f_p$:
$$ f(x_i) = \sum f_p \chi_p (x_i) $$
where $\chi_p$ is the particle characteristic function that defines the volume occupied by the material point:
$$ V_p = \int_{\Omega_p \cap \Omega} \chi_p(x_i) dV $$

In consequent, density, acceleration and stress fields can be approximated by the values stored in particles: 
$$ \rho(x_i) = \sum_p \frac{m_p}{V_{ip}} \chi_p(x_i) \rho(x_i) a_i(x_i) = \sum_p \frac{\dot{p_{ip}}}{V_p} \chi_p(x_i) \sigma_{i j}(x_i) = \sum_p \sigma_{i j p} \chi_p(x_i) $$

where $\dot{p_{ip}} = m_p \dot{v}_{ip} = m_p a_S{ip} = f_{ip}$ is the momentum variation in time that is equal to the total force, regarding the second Newton's law.

Replacing these fields in the weak form of the motion equation we have:

$$ -\sum_p \int_{\Omega_p \cap \Omega} \sigma_{i j p} \chi_p \delta u_{i, j} dV  + \int_{\Gamma} t_i \delta u_i dA+ \sum_p \int_{\Omega_p \cap \Omega} \frac{m_p}{V_p} b_{i p} \chi_p \delta u_i dV 
= \sum_p \int_{\Omega_p \cap \Omega} \frac{\dot{p}_p}{V_p} \chi_p a_i dV $$

In the generalized interpolation material point method (GIMP), the resolution of this equation is carried out using a Petrov–Galerkin scheme where the characteristic functions $\chi_p(x_i)$ are the trial functions and the nodal interpolation functions $N_I(x_i)$ are the test functions.To arrive at this scheme, the virtual displacements are expressed using nodal interpolation functions:

$$ \delta u_i=\sum_I N_{I p} \delta u_{i I} $$

The trial and test functions are such that:

$$ \sum_I N_{I}(x_i) = 1 \sum_p \chi_p(x_i) = 1 $$

The resulting discrete form of the motion equation then is:

$$ f_{iI}^{int} + f_{iI}^{ext} = \dot{p}_{iI} $$

where 

$$p_{iI} = \sum_p S_{Ip} p_{Ip}  $$

is the nodal momentum, 

$$ f_{iI}^{int} = -\sum_p \sigma_{ijp} S_{Ip,j} V_p  $$

is the nodal internal force, and

$$ f_{iI}^{ext} = \sum_p m_p S_{Ip} b_{ip} + \int_{\Gamma} t_i N_I(x_i) dA  $$
 
is the external force at node  $I$.

The function $S_{Ip}$ and its gradients  $S_{Ip,j}$ are the weighting functions of node  $I$ evaluated at the position of particle $p$. 

The GIMP shape functions are defined by 

$$ S_{Ip} =  \frac{1}{V_p} \int_{\Omega_p \cap \Omega} \chi_p(x_i) N_I(x_i) dV $$

and 

$$ S_{Ip,j} =  \frac{1}{V_p} \int_{\Omega_p \cap \Omega} \chi_p(x_i) N_{I,j}(x_i) dV $$ 

These two functions are also a partition of the unity $\sum_I S_{Ip} = 1 $.

The weighting function need to be integrated over the particle domain by choosing different characteristic functions and interpolation functions in a Petrov–Galerkin scheme. In the contiguous particle GIMP (cpGIMP) the characteristic function in defined as step function and the interpolation function is defined as linear function:

$$ \chi_p(x) =
\begin{cases}
1, & x \in \Omega_p, \\
0, & x \notin \Omega_p.
\end{cases} $$
$$
N_I(x)=
\begin{cases}
0, & |x-x_I| \ge L, \\
1+\dfrac{x-x_I}{L}, & -L < x-x_I \le 0, \\
1-\dfrac{x-x_I}{L}, & 0 < x-x_I < L.
\end{cases}
$$

Where the integration is performed analytically within the particle domain.

$$ S_{I p}=\left\{\begin{array}{ll}0 & |\xi| \geq L+l_p 
\\ 
\left(L+l_p+\xi\right)^2 / 4 L l_p & -L-l_p<\xi \leq-L+l_p 
\\ 
1+\xi / L & -L+l_p<\xi \leq-l_p 
\\ 
1-\left(\xi^2+l_p^2\right) / 2 L l_p & \quad-l_p<\xi \leq l_p 
\\ 
1-\xi / L & l_p<\xi \leq L-l_p 
\\ 
\left(L+l_p-\xi\right)^2 / 4 L l_p & L-l_p<\xi \leq L+l_p\end{array}\right.
$$

and

$$
\nabla S_{I p}= \begin{cases}0 & \left|x_p-x_I\right| \geqslant L+l_p, 
\\ \frac{L+l_p+\left(x_p-x_I\right)}{2 L l_p} & -L-l_p<x_p-x_I \leqslant-L+l_p, 
\\ \frac{1}{L} & -L+l_p<x_p-x_I \leqslant-l_p, 
\\ -\frac{x_p-x_I}{L l_p} & -l_p<x_p-x_I \leqslant l_p, 
\\ -\frac{1}{L} & l_p<x_p-x_I \leqslant L-l_p, \\ -\frac{L+l_p-\left(x_p-x_I\right)}{2 L l_p} & L-l_p<x_p-x_I \leqslant L+l_p .\end{cases}
$$

In which $2lp$ is the particle domain, $L$ is the mesh size in 1D, and $\xi$ is the relative particle position to node. Weighting functions in 3D are obtained by the product of three one-dimensional weighting functions:

$$ S_{I p}(x_{i p}) = S_{I p}(\xi) S_{I p} (\eta) S_{I p} (\zeta) $$

where $ \xi=x_p-x_I, \eta=y_p-y_I  $ and  $ \zeta=z_p-z_I $.

\section{Explicit MPM integration}

The discrete form of the motion equation needs to be integrated in time for obtaining the solution in time $t^{n+1}$. The displacement, the velocity and the acceleration at time $t^0, t^1, t^2, ... , t^n$ are knows, and the values at time $t^{n+1}$ are required, namely the solution of the problem. 
The time integration can be done by explicit and implicit methods. In explicit method, the solution $t^{n+1}$ is obtained only with the current information f($t^{n},..., t^{0}$). In implicit method the solution needs to solve a system due the solution is in function of the form f($t^{n+1},...,t^{0}$).

\subsection{Central difference Method}

In central difference method, the velocity at $t^{n+1/2}$ can be approximated as:

$$ \dot{u}^{n+1/2} = (u^{n+1} - u^{n}) \Delta t $$

and, the acceleration in $t^{n}$ can be approximated as:

$$ \ddot{u}^{n} =  (\dot{u}^{n+1/2} - \dot u ^ {n-1/2})\Delta t $$

and therefore, the required displacement at $t^{n+1}$ can be calculated as: $ u^{n+1} = u^{n} + \dot u ^ {n+1/2} \Delta t $, where the velocity is

$$ \dot u^{n+1/2} = \dot{ u } ^ {n-1/2} + \ddot u ^ {n}  \Delta t $$.

The motion equation in time $ t^{n} $ is $ m \, \ddot u ^{n} = f ^{n} $, therefore the acceleration in time $t^{n}$ is $ \ddot u ^{n} = f ^{n} / m $. Using this acceleration equation in the $\dot u^{n+1/2}$ we have the velocity $\dot u ^ {n+1/2}$:

$$
\dot u ^ {n+1/2} = \dot u ^ {n-1/2} + f ^{n} / m \, \Delta t
$$
 
\section{Numerical implementation of central difference method}

For one $\Delta t$, the updated position can be obtained as:

\begin{algorithm}
	\caption{Explicit time integration}
	\begin{algorithmic}[1]
		\State Compute forces $f^n$
		\State Compute acceleration $\ddot{u}^n = f^n/m$
		\State Update velocity $\dot{u}^{n+1/2} = \dot{u}^{n-1/2} + \ddot{u}^n \Delta t$
		\State Update position $u^{n+1} = u^n + \dot{u}^{n+1/2}\Delta t$
		\State $n \leftarrow n + 1$
	\end{algorithmic}
\end{algorithm}

\section{Stability Requirement}

The central difference method is explicit here and conditionally stable, so the time step must be less that a certain value for avoiding error amplification. For linear systems this critical time step value depends on the natural period of the system. For undamped linear systems the critical time step is: $ \Delta t_{cr} = T_n / \pi$, where $ T_n  $ is the smallest natural period of the system. For finite element method, the critical time step of the central difference method can be expressed as:

$$ \Delta t_{cr} = \text{min}_e (l^e/c)$$

Where $l^e $ is the characteristic length of the element and $c$ is the sound speed. This time step restriction implies that time step has to be limited such that a disturbance, a mechanical wave, can travel across the smallest characteristic element length withing a single time step. 

This condition is known as CFL condition, or Courant-Friedrichs-Lewy condition. For linear elastic material the sound speed (compression P wave) is:

$$ c = \sqrt{\frac {E (1-\nu)} {(1+\nu)(1-2\nu) \rho} }$$

In the MPM, the particles can has velocities in any time step, so the critical time speed can be written with this velocity plus:

$$ \Delta t_{cr} = l^e / \text{max}_p ( c_p + |v_p| )$$

In a structured regular mesh, $l^e$ is the grid cell dimension. And $c_p$ is the sound speed calculated with the material parameters stored in particles.

\section{ Numerical damping }

Real materials dissipates energy during movement. Temperature ans plastic deformation are common sources of energy dissipation. In numerical analysis numerical damping can be used for obtaining the quasi-static condition of the dynamic system.

\section{ Local damping }

The numerical damping is a technique for getting a stationary solution of the dynamic system. In the MPM-Geomechanics simulator we have two type of numerical damping: the local (viscous) and the kinetic (dynamic relaxation) damping.

\subsection{Quasi-static solution with local damping}

The local damping is used to get a quasi-static solution of the dynamic system using a viscous nodal force. In each time step, a viscous force is applied in each node, whose magnitude is proportional and opposite to the nodal velocity.

$$ f_{iI}^{dnplocal} = - \alpha |f_{iI}^{unb}| \hat{v}_{iI} $$

, where the unbalanced nodal force is:

$$ f_{iI}^{unb} =  f_{iI}^{int} + f_{iI}^{ext} $$

Therefore, the resulting discrete form of the motion equation with viscous nodal damping is:

$$ \dot{p}_{iI} = f_{iI}^{int} + f_{iI}^{ext} + f_{iI}^{dnplocal} $$

\section{Explicit MPM Scheme}


\begin{algorithm}
	\caption{Explicit MPM integration scheme}
	\begin{algorithmic}[1]
		\State Compute nodal mass:
		$ m_I^k = \sum_{p=1}^{n_p} m_p N_{Ip}^k $
		\State Compute nodal momentum:
		$ p_{iI}^{k-1/2} = \sum_{p=1}^{n_p} m_p v_{ip}^{k-1/2} N_{Ip}^k $
		\State Impose boundary conditions on $p_{iI}^{k-1/2}$		
		
    \State Calculate nodal velocities:
    $ v_{iI}^{k-1/2} = p_{iI}^{k-1/2} / m_I^k $

    \State Compute particle strain increment:
		$ \Delta \varepsilon_{ij}^p{}^{k-1/2}
		= \frac{1}{2}\left(
		N_{p,j}^k v_i^{k-1/2}
		+ N_{p,i}^k v_j^{k-1/2}
		\right)\Delta t $
		
		\State Compute vorticity increment: 
		$ \Delta \omega_{ij}^p{}^{k-1/2}
		= \frac{1}{2}\left(
		N_{p,j}^k v_i^{k-1/2}
		- N_{p,i}^k v_j^{k-1/2}
		\right)\Delta t $

    \State Update particle density:
    $ \rho_p^{k+1} = \rho_p^{k} / (1 + \text{tr}(\Delta \varepsilon_{ijp}^{k-1/2})) $
		
    \State Update particle stress:
    $ \sigma_{ij}^{p}{}^{k+1} = \text{StressUpdate}(\sigma_{ij}^{p}{}^{k}, \Delta \varepsilon_{ij}^p{}^{k-1/2}, \Delta \omega_{ij}^p{}^{k-1/2} ) $

	\end{algorithmic}
\end{algorithm}

\subsection{Update Stress First - USF - Scheme}
In the USF scheme the velocities in  $ n-1/2  $ are used to update the stress state:

\subsection{Update Stress Last - USL - Scheme}
In the USL scheme the updated velocities in nodes  $ n+1/2  $ are used to update the stress state:

\subsection{Modified Update Stress Last - MUSL - Scheme}
In the Modified USL scheme, the updated particle velocities are used to update the stress state: 

\section{Project structure}

The project is organized such as:

\begin{itemize}
  \item \texttt{src/ and inc/} sources and headers C++ files
  \item \texttt{manual/} program manual (e.g., STL), DEMs, etc.
  \item \texttt{tests/} simulation results of analytical and numerical tests
  \item \texttt{examples/} implementation verification and application examples
\end{itemize}

\section{Build commands}

\noindent Instruction commands using Linux/WSL:

\begin{lstlisting}[language=bash]
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
./build/MPM-Geomechanics --input inputs/base_case.json
\end{lstlisting}

\section{Program features}

The main features of the program are:

\begin{itemize}   
\item Three-dimensional 3D formulation
\item Dynamic formulation
\item Shared memory parallelization using OpenMP
\item Many ways to crate bodies (polygons, particle list, pre-defined bodies)
\item Several constitutive models for soil and rock materials
\item Softening/hardening models to represent weakness during large deformations 
\item Coupled fluid-mechanical formulation (*under development*)
\end{itemize}

\section{Compiled binaries}
For downloading the compiled binaries
\begin{itemize}
  \item Go to the [Actions page](https://github.com/fabricix/MPM-Geomechanics/actions).
  \item Select the latest run of the **MSBuild** workflow for Window, or **CI** for Linux.
  \item At the bottom, you will find the available artifacts under the **Artifacts** section.
  \item Download the `compiled-binaries` artifact to get the compiled code.
\end{itemize}

\section{Required Programs}

\label{sec:required_programs}

The following instructions outline the steps required to install all necessary programs to build the MPM-Geomechanics project and execute its test suite.

\subsection{Required Programs - Windows}

\label{sec:required_programs_windows}
\begin{table}[h!]
	\centering
	\begin{tabularx}{\textwidth}{|l|X|X|}
		\hline
		\textbf{Program} & \textbf{Installation} & \textbf{Command} \\
		\hline
		\textbf{Winget} & \href{https://learn.microsoft.com/en-us/windows/package-manager/winget/}{Microsoft's official website} & Native of Windows \\
		\textbf{Git} & via Winget & \texttt{winget install -e --id Git.Git -e --source winget} \\
		\textbf{MSYS2} & via Winget & \texttt{winget install -e --id MSYS2.MSYS2 --source winget} \\
		\textbf{GitHub CLI} & via MSYS2 MINGW64 & \texttt{pacman -S mingw-w64-x86\_64-github-cli} \\
		\textbf{Python} & via MSYS2 MINGW64 & \texttt{pacman -S mingw-w64-x86\_64-python} \\
		\textbf{CMake} & via MSYS2 MINGW64 & \texttt{pacman -S mingw-w64-x86\_64-cmake} \\
		\textbf{GCC} & via MSYS2 MINGW64 & \texttt{pacman -S mingw-w64-x86\_64-gcc} \\
		\textbf{G++} & via MSYS2 MINGW64 & \texttt{pacman -S mingw-w64-x86\_64-gcc} \\
		\textbf{Make} & via MSYS2 MINGW64 & \texttt{pacman -S make} \\
		\hline
	\end{tabularx}
	\caption{Programs required for Windows installation.}
\end{table}


\noindent
\textbf{Make sure you have Winget installed.} You can verify this by running \texttt{winget --version}.  
If you don't have Winget installed, you can get it from \href{https://learn.microsoft.com/en-us/windows/package-manager/winget/}{Microsoft's official website}.

\subsubsection*{Step 1: Install Git, GitHub, and MSYS2}
Run the following commands:

\begin{verbatim}
winget install -e --id Git.Git -e --source winget
winget install -e --id MSYS2.MSYS2 --source winget
\end{verbatim}

\subsubsection*{Step 2: Install required packages in MSYS2 MINGW64}

\begin{lstlisting}
pacman -S mingw-w64-x86_64-github-cli
pacman -S mingw-w64-x86_64-python
pacman -S mingw-w64-x86_64-cmake
pacman -S mingw-w64-x86_64-gcc
pacman -S make
\end{lstlisting}

\subsubsection*{Step 3: Verify the installations}

\begin{lstlisting}
git --version
gh --version
python --version
cmake --version
make --version
gcc --version
g++ --version
\end{lstlisting}

\clearpage

\subsection{Required Programs - Linux}
\label{sec:required_programs_linux}

\begin{table}[h!]
\centering
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\textbf{Program} & \textbf{Installation} & \textbf{Command} \\
\hline
\textbf{Git} & via apt & \texttt{sudo apt install git} \\
\textbf{GitHub CLI} & via apt & \texttt{sudo apt install gh} \\
\textbf{Python} & via apt & \texttt{sudo apt install python3 python3-pip} \\
\textbf{CMake} & via apt & \texttt{sudo apt install cmake} \\
\textbf{GCC} & via apt & \texttt{sudo apt install build-essential} \\
\textbf{G++} & via apt & \texttt{sudo apt install build-essential} \\
\textbf{Make} & via apt & \texttt{sudo apt install build-essential} \\
\hline
\end{tabularx}
\caption{Programs required for Linux installation.}
\end{table}

\subsubsection*{Step 1: Install all packages via apt}

\begin{lstlisting} [language=bash, caption={Installing required packages using \textit{apt}}]
sudo apt install git
sudo apt install gh
sudo apt install python3 python3-pip
sudo apt install cmake
sudo apt install build-essential
\end{lstlisting}

\subsubsection*{Step 2: Verify the installations}

\begin{verbatim}
git --version
gh --version
python3 --version
cmake --version
make --version
gcc --version
g++ --version
\end{verbatim}


\subsection{Compilation in Windows}

Prior to proceeding with these instructions, please consult the windows required programs section in this manual.

The simplest way to compile on windows is by using the `.bash` file at `/build/CMake` with `MSYS2 MINGW64` console line, just execute:

\begin{lstlisting}
  cd project-directory/build/CMake
./cmake-build.bash
\end{lstlisting}

Alternatively, you can use the following commands:

\begin{lstlisting}
  cd project-directory/build/CMake
  cmake -G "Unix Makefiles" -B build
  cmake --build build
\end{lstlisting}

\subsection{ Compiling on Linux } 

Prior to proceeding please consult the Linux Required Programs section in this manual.

The simplest way to compile on Linux is by using the `.bash` file at `/build/CMake`, just execute:

\begin{lstlisting}	
 cd build/CMake
 ./cmake-build.bash
\end{lstlisting}

Alternatively, you can use the following commands:

\begin{lstlisting}	
cd build/CMake
cmake -G "Unix Makefiles" -B build
cmake --build build
\end{lstlisting}

\section{Visual Studio Solution}

For compiling the code in windows you can use the Visual Studio solution file `/build/MPM-Geomechanics.sln`, and build it by pressing `Ctr+B`.
Alternatively you can compile it by using command in a *Developer Command Prompt*: 

\begin{lstlisting}
msbuild MPM-Geomechanics.sln -p:Configuration=Release
\end{lstlisting}

\section{ Make Compilation }

For compile the code in a linux environment, execute the makefile inside the make folder: \verb| MPM-Geomechanics\build\make\makefile|.
 
\section{Documentation}

The program documentation is generated using Doxygen documentation generator.

\begin{lstlisting}
doxygen Doxyfile
\end{lstlisting}

The HTML generated documentation is located in `/docs/index.html`.

\section{Execution}

In order to run simulations in several terminal, you can add the compiled code in the system `PATH`.

\section{Testing Compilation and Benchmarking} 

\label{sec:testing_manual_howto_compile}

\section{How to Compile} 

Prior to proceeding with these instructions, please consult required programs in manual.

The tests use **GoogleTest**. It is necessary to import this library by cloning the official repository into the folder `/external`. Each developer must clone this repository independently.

```
cd external
git clone https://github.com/google/googletest.git
```

The simplest way to compile on Windows and Linux is by using the `.bash` file at `/build/qa` with `MSYS2 MINGW64` console line, simply execute the following command in the directory `MPM-Geomechanics/build/qa`:
```
./cmake-build.bash
```

Alternatively, you can use the following commands:
```
cmake -G "Unix Makefiles" -B build
```

```
cmake --build build
```

These commands will generate two executables: `MPM-Geomechanics-tests` and `MPM-Geomechanics-benchmark`.

- `MPM-Geomechanics-tests`: Run testing using GoogleTest. All files ending with `.test.cpp` are testing files, you can find them in the directory `qa/tests`.

- `MPM-Geomechanics-benchmark`: Run benchmark using GoogleTest. All files ending with `.benchmark.cpp` are performance files. You can find them in the directory `qa/benchmark`.

\section {How does benchmarking work?}

If you are using Windows OS, make sure to use the MINGW64 command-line console.

\subsection {Executable MPM-Geomechanics-benchmark}

To run the benchmark correctly, a JSON file named \texttt{benchmark-configuration.json} is required. This file allows the user to specify values for each test. If the file does not exist or a value is missing, a default value will be used.

The executable \texttt{MPM-Geomechanics-benchmark} allows the following command-line arguments:

\texttt{<directory>}: Specifies which file should be used to run the benchmark. If no file is specified, the program will use \texttt{benchmark-configuration.json} located in the same directory as the executable. Example: \texttt{MPM-Geomechanics-benchmark configuration-file.json}

The executable \texttt{MPM-Geomechanics-benchmark} allows the following command-line flags:

\texttt{--log}: Shows more information about missing keys in the \texttt{benchmark-configuration.json} file

\subsection {Script (executable): start-multi-benchmark.py}

The performance test can also be executed using the `start-multi-benchmark.py` script, which allows running benchmarks with one or more executables downloaded as artifacts from GitHub and stores the log results in separate folders. Each executable is automatically downloaded from GitHub as an artifact, using an ID specified in \texttt{start-multi-benchmark-configuration.json}. Additionally, the benchmark configuration (number of martial points and number of threads) can be defined in the same file. 

Example of a \texttt{start-multi-benchmark-configuration.json} file:

\begin{lstlisting}
{
	"executables": {
		"win_benchmark_executable": "MPM-Geomechanics-benchmark.exe",  -> An executable located at build/qa/MPM-Geomechanics-benchmark.exe
    	"win_github_id": "17847226555"  -> An artifact ID that represent it. can check out if it exists via gh run view <ID>
 	},
	"parameters": {
		"particles": [ 15000, 25000, 50000],  -> material point to test
		"threads": [1, 5, 10]  -> number of threads to test
	}
}
\end{lstlisting}

This setup will run 3x3 (particles x threads) totaling 18 tests (3x3x2)

The executable \texttt{start-multi-benchmark.py} allows the following command-line flags:

\texttt{--clear}: Removes the **benchmark folder** (if it exists) before executing the performance tests.
\texttt{--cache}: Uses the previously created cache instead of the \texttt{start-multi-benchmark-configuration.json} file.

\clearpage

\section{Verification Problems}
\label{sec:verification_problems}

\subsection{Local damping}

For using the local damping force with $ \alpha = 0.145  $:

\begin{lstlisting}[language={}, caption={Defining local damping in json file.}]
	"damping":{"type"=":"local", "value":0.145}
\end{lstlisting}

The stress field obtained from a local damping forced system, cam be used as initial stress field value.

\subsection{Load and save states}

In static analysis, the quasi static analysis can be store in to a simulation state:

\begin{lstlisting}[language={},caption={input JSON}]
	"save_state":true,
\end{lstlisting}

And for loading the salved state

\begin{lstlisting}[language={},caption={input JSON}]
	"load_state":true,
\end{lstlisting}

\subsection{Boussinesq's Problem}
\label{sec:boussinesq_problem}

\subsubsection*{Introduction}

In Geomechanics, the Boussinesq's problem refers to the point load acting on a surface of an elastic half-space.  
The boundary conditions for this problem are:

\begin{itemize}
    \item The load \( P \) is applied only at one point, at the origin.
    \item The load is zero at any other point.
    \item For any point infinitely distant from the origin, the displacements must all vanish.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.45\textwidth]{figures//boussinesq-problem.png}
    \caption{Boussinesq's problem.}
    \label{fig:boussinesq_problem}
\end{figure}

\subsubsection*{Analytical Solution}

The analytical solution of the vertical displacement field is:
\[
    u_z(x,y,z) = \frac{P}{4 \pi G d} \left( 2 (1-\nu) + \frac{z^2}{d^2} \right)
\]
where \( G = \frac{E}{2(1+\nu)} \) is the shear modulus of the elastic material,  
\( \nu \) is the Poisson ratio, and \( d = \sqrt{ x^2 + y^2 + z^2 } \) is the total distance from the load to the point.

\subsubsection*{MPM Model and Result Comparison}

To model the displacement field generated by the point load, we create an elastic body with dimensions  
\( l_x = l_y = l_z = 1\,\text{m} \), using the keyword \texttt{"cuboid"} with Point 1 at (0,0,0) and Point 2 at (1,1,1).

For the elastic parameters:
\[
E = 200 \times 10^6\,\text{Pa}, \quad \rho = 1500\,\text{kg/m}^3, \quad \nu = 0.25
\]

The computational mesh has cell dimensions \( \Delta x = \Delta y = \Delta z = 0.1\,\text{m} \).  
A nodal load of magnitude 1 is applied in the vertical direction at the midpoint of the upper surface.  
The plane \( Z_n \) is free, while all other planes are sliding (only tangential displacements allowed).  
Dynamic relaxation is used to reach a static solution, through the keyword \texttt{"damping"} with type \texttt{"kinetic"}.

\subsubsection*{Input File}

\begin{lstlisting}
{
    "body": {
        "elastic-cuboid-body": {
            "type":"cuboid",
            "id":1,
            "point_p1":[0.0,0.0,0],
            "point_p2":[1,1,1],
            "material_id":1
        }
    },
    "materials": {
        "material-1": {
            "type":"elastic",
            "id":1,
            "young":200e6,
            "density":1500,
            "poisson":0.25
        }
    },
    "mesh": { 
        "cells_dimension":[0.1,0.1,0.1],
        "cells_number":[10,10,10],
        "origin":[0.0,0.0,0.0],
        "boundary_conditions": {"plane_Zn":"free"}
    },
    "time":0.025,
    "time_step_multiplier":0.3,
    "nodal_point_load": [[[0.5, 0.5, 1.0], [0.0, 0.0, -1.0]]],
    "damping": {"type":"kinetic" }
}
\end{lstlisting}

The MPM numerical results show good agreement with the analytical solution,  
with small deviations due to discretization and the representation of the domain by particles with finite volume.  
Errors decrease with mesh refinement.

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/boussinesq-problem-verification.png}
    \caption{Comparison between analytical and MPM results.}
    \label{fig:boussinesq_verification}
\end{figure}

\clearpage
\subsection{Base Acceleration Example}
\label{sec:base_acceleration_example}

\subsubsection*{Introduction}

In this example we model the motion of an elastic body subjected to a dynamic boundary condition.  
The body is a cuboid with dimensions \( l_x = l_y = 0.3\,\text{m} \) and \( l_z = 0.8\,\text{m} \),  
with lower coordinate point \( p_{min} = (0.4, 0.4, 0.0)\,\text{m} \).

The base acceleration is defined as:
\[
\ddot{u} = A\,2\pi f \cos(2\pi f t + \alpha)
\]

The total simulation time is \( T = 2\,\text{s} \), with a time step \( \Delta t = 10^{-4}\,\text{s} \).  
Material properties:
\[
\rho = 2500\,\text{kg/m}^3, \quad E = 100 \times 10^6\,\text{Pa}, \quad \nu = 0.25
\]

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/geometry-body.png}
    \caption{Geometry of the elastic body.}
    \label{fig:geometry_body}
\end{figure}

\subsubsection*{MPM Model}

The MPM model consists of uniformly distributed particles inside the body, created with the keywords  
\texttt{"body"} and \texttt{"cuboid"}. The mesh dimensions are \( \Delta x = \Delta y = \Delta z = 0.1\,\text{m} \),  
and it covers the full expected displacement range of the body.  
The mesh uses \( n_x = 12, n_y = 12, n_z = 15 \).

\subsubsection*{Input File}

\begin{verbatim}
{
  "stress_scheme_update":"USL",
  "shape_function":"GIMP",
  "time":10,
  "time_step":0.0005,
  "gravity":[0.0,0.0,0.0],
  "n_threads":1,
  "damping": {
    "type":"local",
    "value":0.0
  },
  "results": {
    "print":100,
    "fields":["id","displacement","velocity","material","active","body"]
  },
  "n_phases":1,
  "mesh": { 
    "cells_dimension":[0.1,0.1,0.1],
    "cells_number":[10,10,15],
    "origin":[0,0,0]
  },
  "earthquake": {
    "active": true,
    "file": "base_acceleration.csv",
    "header": true
  },
  "material": {
    "elastic_1": {
      "type":"elastic",
      "id":1,
      "young":10e6,
      "density":2500,
      "poisson":0.25
    }
  },
  "body": {
    "columns_1": {
      "type":"cuboid",
      "id":1,
      "point_p1":[0.2,0.2,0],
      "point_p2":[0.5,0.5,1.0],
      "material_id":1
    }
  }
}
\end{verbatim}

\subsubsection*{Earthquake Block Parameters}

\begin{verbatim}
"earthquake": {
  "active": true,
  "file": "base_acceleration.csv",
  "header": true
}
\end{verbatim}

Where:
\begin{itemize}
    \item \textbf{active}: Enables or disables seismic loading.
    \item \textbf{file}: Path to the CSV file containing time, acceleration\_x, acceleration\_y, and acceleration\_z.
    \item \textbf{header}: True if the CSV has a header row.
\end{itemize}

Example of the first lines of the record:

\begin{verbatim}
t,ax,ay,az
0.0,-1.8849555921538759,-0.9424777960769379,-0.0
5e-05,-1.8849554991350466,-0.9424777844495842,-0.0
0.0001,-1.884955220078568,-0.9424777495675233,-0.0
0.00015000000000000001,-1.8849547549844674,-0.9424776914307561,-0.0
...
\end{verbatim}

\subsubsection*{Results and Visualization}

After simulation, particle results are found in the \texttt{/particle} directory,  
and grid results in the \texttt{/grid} directory.  
Particle results (\texttt{particle\_1.vtu}, \texttt{particle\_2.vtu}, ..., \texttt{particle\_41.vtu})  
are referenced in \texttt{particleTimeSerie.pvd}, which can be opened in ParaView:

\begin{verbatim}
File → Open → particleTimeSerie.pvd
\end{verbatim}

The mesh can be loaded with:

\begin{verbatim}
File → Open → eulerianGrid.vtu
\end{verbatim}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/mpm-model-particles-and-mesh.png}
    \caption{Particles and mesh of the analyzed case.}
    \label{fig:mpm_particles_mesh}
\end{figure}

\subsubsection*{Verification of Dynamic Boundary Condition}

The velocity from the analytical input function
\[
\dot{u} = A \sin(2 \pi f t + \alpha)
\]
was compared with the particle velocity at the base of the model.  
The results show excellent agreement between analytical and MPM-calculated velocities.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figures//velocity-base-verification.png}
    \caption{Verification of velocities obtained with MPM simulation.}
    \label{fig:velocity_base_verification}
\end{figure}

\end{document}